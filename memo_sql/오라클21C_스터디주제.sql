
--테이블 생성 및 데이터 삽입
CREATE TABLE ORDERS (
    ORDER_ID NUMBER PRIMARY KEY,
    CUSTOMER_ID NUMBER,
    ORDER_DATE DATE,
    ORDER_DETAILS JSON -- 주문 상세 정보를 JSON 형태로 저장
);

INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_DETAILS) VALUES (101, 1, DATE '2025-01-15', '{"items": [{"product_name": "Laptop", "qty": 1, "price": 1200}, {"product_name": "Mouse", "qty": 1, "price": 25}], "shipping_address": {"street": "123 Main St", "city": "Seoul","zip": "03100"}, "total_amount": 1225}');
INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_DETAILS) VALUES (102, 2, DATE '2025-02-20', '{"items": [{"product_name": "Keyboard", "qty": 1, "price": 75}, {"product_name": "Monitor", "qty": 2, "price": 300}], "shipping_address": {"street": "456 Park Ave", "city": "Busan", "zip": "48000"}, "total_amount": 675}');
INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_DETAILS) VALUES (103, 1, DATE '2025-03-10', '{"items": [{"product_name": "Webcam", "qty": 1, "price": 50}], "shipping_address": {"street": "123 Main St", "city": "Seoul", "zip": "03100"}, "total_amount": 50}');
INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_DETAILS) VALUES (104, 3, DATE '2025-04-05', '{"items": [{"product_name": "Headphones", "qty": 1, "price": 150}, {"product_name": "Microphone", "qty": 1, "price": 80}], "shipping_address": {"street": "789 River Rd", "city": "Daegu", "zip": "41900"}, "total_amount": 230}');
COMMIT;

--1. 모든 주문의 ORDER_ID와 ORDER_DETAILS 전체를 조회하세요.
SELECT ORDER_ID, ORDER_DETAILS
FROM ORDERS

SELECT ORDER_ID, 
json_query(ORDER_DETAILS,'$')
FROM ORDERS


--2. ORDER_ID가 101인 주문의 배송지 city를 조회하세요.
SELECT
  json_value(ORDER_DETAILS, '$.shipping_address.city') as city
FROM ORDERS
WHERE ORDER_ID=101

--json_value() : 배열안의 단일 키 추출
--json_query() : 배열안의 객체/배열 그대로 추출
--$.shipping_address : shipping_address 키

--3. 모든 주문에 대해 ORDER_ID, 주문의 총 상품 개수(items 배열의 길이), 그리고 total_amount를 조회하세요.
SELECT o.ORDER_ID, 
       (
       SELECT COUNT(*)
       FROM json_table(
       o.ORDER_DETAILS,
       '$.items[*]'
       COLUMNS(
        idx FOR ORDINALITY
       )
       )
       ) AS "주문의 총 상품 개수", 
       json_value(o.ORDER_DETAILS, '$.total_amount')
FROM ORDERS o

--json_table(...) : items 배열 전체 요소를 펼침
--$.items[*] item안의 배열 전체 요소를 대상으로 함
--FOR ORDINALITY: 각 요소에 1, 2, 3 번호 붙임
--COLUMNS () : json_table 에서 테이블의 컬럼으로 만들것인지 정의 여기서는 


--비고 .size() : JSON Path 안에서 사용하는 size() 내장 함수
SELECT ORDER_ID, 
       json_value(ORDER_DETAILS, '$.items.size()') AS "주문의 총 상품 개수", 
       json_value(ORDER_DETAILS, '$.total_amount')
FROM ORDERS 


--4. 주문 상품 중 'Laptop'이 포함된 모든 주문의 ORDER_ID와 CUSTOMER_ID를 조회하세요.
SELECT ORDER_ID, CUSTOMER_ID
FROM ORDERS
WHERE json_exists(ORDER_DETAILS, '$.items[*]?(@.product_name like "%Laptop%")')

--json_exists() : 배열 안에 특정 값이 존재하는지 파악
--items[*] : item안의 배열 전체 요소
--?() : 필터 조건
--@.product_name : 객체안의 특정필드(product_name) 접근


--5. ORDER_DETAILS의 items 배열 내 각 상품의 product_name, qty, price를 개별 컬럼으로 분리하여 조회하고, 해당 주문의 ORDER_ID도 함께 출력하세요. (힌트: JSON_TABLE)
SELECT o.ORDER_ID, jt.product_name, jt.qty, jt.price
FROM ORDERS O,
    json_table(
      o.ORDER_DETAILS,
      '$.items[*]'
      COLUMNS(
      product_name VARCHAR2(100) PATH '$.product_name',
      qty NUMBER PATH '$.qty',
      price NUMBER PATH '$.price'
      )
    ) jt

--비고 items의 첫번째 배열만 추출
SELECT o.ORDER_ID, 
       json_value(o.ORDER_DETAILS, '$.items[0].product_name') AS first_product,
       json_value(o.ORDER_DETAILS, '$.items[0].qty') AS qty,
       json_value(o.ORDER_DETAILS, '$.items[0].price') AS price
FROM ORDERS o;

--6. 각 고객(CUSTOMER_ID)별로 주문한 상품들의 총 금액을 합산하여 조회하세요.
SELECT o.CUSTOMER_ID, SUM(jt.qty*jt.price)
FROM ORDERS O,
    json_table(
      o.ORDER_DETAILS,
      '$.items[*]'
      COLUMNS(
      product_name VARCHAR2(100) PATH '$.product_name',
      qty NUMBER PATH '$.qty',
      price NUMBER PATH '$.price'
      )
    ) jt
GROUP BY  o.CUSTOMER_ID   

SELECT 
  CUSTOMER_ID,
  SUM(JSON_VALUE(ORDER_DETAILS, '$.total_amount')) AS total_spent
FROM ORDERS
GROUP BY CUSTOMER_ID;



--오라클 버전확인
SELECT * FROM V$VERSION;



CREATE BLOCKCHAIN TABLE AUDIT_LOG (
    LOG_ID RAW(16) DEFAULT SYS_GUID() NOT NULL,
    EVENT_TYPE VARCHAR2(50) NOT NULL,
    EVENT_DETAILS VARCHAR2(200),
    EVENT_TIMESTAMP TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    ACTOR_USER VARCHAR2(50) NOT NULL
) NO DROP UNTIL 0 DAYS NO DELETE UNTIL 0 DAYS;



INSERT INTO AUDIT_LOG (EVENT_TYPE, EVENT_DETAILS, ACTOR_USER) VALUES ('Login Success', 'User session started', 'admin');
INSERT INTO AUDIT_LOG (EVENT_TYPE, EVENT_DETAILS, ACTOR_USER) VALUES ('Data Update', 'Updated customer record 105', 'user_a');
INSERT INTO AUDIT_LOG (EVENT_TYPE, EVENT_DETAILS, ACTOR_USER) VALUES ('Login Failed', 'Invalid password attempt', 'hacker');
COMMIT;


--테이블 생성 및 데이터 삽입
CREATE TABLE product_catalog (
    product_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    product_info CLOB, -- JSON 데이터를 저장할 컬럼
    CONSTRAINT pk_product_catalog PRIMARY KEY (product_id),
    CONSTRAINT chk_product_info_json CHECK (product_info IS JSON) -- JSON 형식 검증 제약 조건
);

-- JSON 검색 인덱스 생성 (성능 최적화)
CREATE SEARCH INDEX product_info_sidx ON product_catalog (product_info) FOR JSON;


INSERT INTO product_catalog (product_info) VALUES (
    '{"name": "Laptop Pro", "category": "Electronics", "price": 1200.00, "features": ["16GB RAM", "512GB SSD", "Intel i7"], "reviews": [{"user": "Alice", "rating": 5, "comment": "Excellent performance"}, {"user": "Bob", "rating": 4, "comment": "Good value for money"}]}'
);

INSERT INTO product_catalog (product_info) VALUES (
    '{"name": "Wireless Mouse", "category": "Accessories", "price": 25.50, "features": ["Ergonomic design", "Bluetooth"], "reviews": [{"user": "Charlie", "rating": 5, "comment": "Very comfortable"}, {"user": "David", "rating": 3, "comment": "Sometimes disconnects"}]}'
);

INSERT INTO product_catalog (product_info) VALUES (
    '{"name": "Mechanical Keyboard", "category": "Accessories", "price": 99.99, "features": ["RGB Backlight", "Tactile switches"], "reviews": [{"user": "Eve", "rating": 4, "comment": "Great for typing"}, {"user": "Frank", "rating": 5, "comment": "Awesome for gaming"}]}'
);

INSERT INTO product_catalog (product_info) VALUES (
    '{"name": "Smartphone XYZ", "category": "Electronics", "price": 850.00, "features": ["AMOLED Display", "Dual Camera", "Fast Charging"], "reviews": [{"user": "Grace", "rating": 5, "comment": "Fantastic phone"}, {"user": "Henry", "rating": 4, "comment": "Battery life could be better"}]}'
);

-- 1-1. 모든 제품의 **이름(name)**과 **가격(price)**을 조회하시오.
SELECT  json_value(product_info, '$.name'),
        json_value(product_info, '$.price')
FROM    PRODUCT_CATALOG;


-- 1-2. 카테고리가 'Electronics'인 제품의 이름을 조회하시오.
SELECT  json_value(product_info, '$.name')
FROM    PRODUCT_CATALOG
WHERE   json_value(product_info, '$.category') = 'Electronics';

-- 1-3. '16GB RAM' 기능을 포함하는 제품의 이름과 가격을 조회하시오. (JSON 배열 내부 검색)
SELECT json_value(product_info, '$.name'),
        json_value(product_info, '$.price')
FROM    PRODUCT_CATALOG
WHERE   json_exists(product_info, '$?(@.features like "%16GB RAM%")')
;
-- 1-4. 각 제품의 리뷰 중 평점(rating)이 4점 이상인 **리뷰 사용자(user)**와 해당 **리뷰 코멘트(comment)**를 제품별로 조회하시오. (SQL/JSON 함수 JSON_TABLE 활용)
SELECT  jt."USER", jt."COMMENT"
FROM    PRODUCT_CATALOG c,
        json_table(
            c.product_info,
            '$.reviews[*]'
            COLUMNS(
            "USER" VARCHAR2(100) PATH '$.user',
            "COMMENT" VARCHAR2(100) PATH '$.comment',
            "RATING" NUMBER PATH '$.rating'
            )
        ) jt
WHERE jt."RATING">=4;   
        
SELECT  json_value(product_info, '$.reviews[0].user'),
        json_value(product_info, '$.reviews[0].comment')
FROM    PRODUCT_CATALOG

SELECT product_info FROM product_catalog;

-- 1-5. 가장 비싼 제품의 이름을 조회하시오.
SELECT  json_value(product_info, '$.name')
FROM    PRODUCT_CATALOG
ORDER BY TO_NUMBER(json_value(product_info, '$.price')) desc
FETCH FIRST 1 ROWS ONLY



--테이블 생성 및 데이터 삽입
CREATE TABLE sales_transactions (
    transaction_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    product_category VARCHAR2(100) NOT NULL,
    item_name VARCHAR2(100) NOT NULL,
    transaction_date DATE NOT NULL,
    quantity NUMBER NOT NULL,
    unit_price NUMBER(10, 2) NOT NULL,
    region VARCHAR2(50),
    CONSTRAINT pk_sales_transactions PRIMARY KEY (transaction_id)
);

INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Electronics', 'Laptop A', TO_DATE('2024-05-01', 'YYYY-MM-DD'), 1, 1500.00, 'Seoul');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Electronics', 'Mouse B', TO_DATE('2024-05-01', 'YYYY-MM-DD'), 3, 25.00, 'Seoul');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Apparel', 'T-Shirt C', TO_DATE('2024-05-02', 'YYYY-MM-DD'), 5, 15.00, 'Busan');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Electronics', 'Keyboard D', TO_DATE('2024-05-03', 'YYYY-MM-DD'), 2, 80.00, 'Seoul');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Apparel', 'Jeans E', TO_DATE('2024-05-03', 'YYYY-MM-DD'), 1, 60.00, 'Busan');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Books', 'Novel F', TO_DATE('2024-05-04', 'YYYY-MM-DD'), 2, 20.00, 'Jeju');
INSERT INTO sales_transactions (product_category, item_name, transaction_date, quantity, unit_price, region) VALUES ('Electronics', 'Laptop A', TO_DATE('2024-05-05', 'YYYY-MM-DD'), 1, 1500.00, 'Busan');



-- 2-1. 특정 날짜 범위(start_date, end_date) 내의 총 판매액을 계산하는 SQL 매크로 함수를 작성하고 사용하시오. 이 매크로는 입력받은 날짜 범위에 따라 동적으로 WHERE 절이 생성되어야 합니다.
--힌트: DBMS_MACRO.CREATE_MACRO_FUNCTION을 사용하여 매크로를 정의하고, SQL_MACRO 키워드를 사용합니다.

-- 2-2. 특정 product_category의 평균 판매 단가를 계산하는 SQL 매크로 함수를 작성하고 사용하시오. 이 매크로는 product_category 인자를 받아 해당 카테고리의 데이터를 필터링해야 합니다.

-- 2-3. 판매된 **총 수량(quantity)**과 **총 판매 금액(quantity * unit_price)**을 반환하는 SQL 매크로 함수를 작성하시오. (테이블 전체 또는 특정 조건을 필터링하여 적용 가능하게)


--테이블 생성 및 데이터 삽입(아직 못함)
-- HASHING USING 절은 Oracle 23c에서 도입된 기능 지금 이 버전은 21버전

-- 블록체인 테이블 생성 (Drop 및 Insert 옵션 지정)
CREATE BLOCKCHAIN TABLE sensor_readings (
    reading_id NUMBER GENERATED ALWAYS AS IDENTITY,
    sensor_name VARCHAR2(100) NOT NULL,
    reading_value NUMBER NOT NULL,
    reading_timestamp TIMESTAMP WITH LOCAL TIME ZONE NOT NULL,
    location VARCHAR2(100)
) NO DROP UNTIL 7 DAYS AFTER INSERT -- 삽입 후 7일이 지나야 DROP 가능
    NO DELETE UNTIL 7 DAYS AFTER INSERT -- 삽입 후 7일이 지나야 DELETE 가능
    HASHING USING "SHA2_256" VERSION "V1"; -- 해싱 알고리즘 지정


INSERT INTO sensor_readings (sensor_name, reading_value, reading_timestamp, location) VALUES ('Temperature_Sensor_1', 25.5, SYSTIMESTAMP, 'Warehouse_A');
INSERT INTO sensor_readings (sensor_name, reading_value, reading_timestamp, location) VALUES ('Humidity_Sensor_2', 60.2, SYSTIMESTAMP, 'Server_Room_B');
INSERT INTO sensor_readings (sensor_name, reading_value, reading_timestamp, location) VALUES ('Pressure_Sensor_3', 101.3, SYSTIMESTAMP, 'Factory_Floor_C');
INSERT INTO sensor_readings (sensor_name, reading_value, reading_timestamp, location) VALUES ('Temperature_Sensor_1', 26.1, SYSTIMESTAMP, 'Warehouse_A');
INSERT INTO sensor_readings (sensor_name, reading_value, reading_timestamp, location) VALUES ('Humidity_Sensor_2', 61.5, SYSTIMESTAMP, 'Server_Room_B');


-----------------------------------------------------------




